package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, LBRACE, RBRACE, NAMESPACE, CONST, EQUAL, COMMA, SEMI, STATIC;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal String BOOLCONST ;
terminal String LETTER ;
terminal LBOXBRAC, RBOXBRAC, LPAREN, RPAREN, COL, IF, BREAK, ELSE, CONTINUE;
terminal RETURN, FOR, ASTERISK, INC, DEC, OR, AND, NEW, DOT, EQUALEQUAL, DIFF;
terminal GT, GET, LT, LET, PLUS, MINUS, VOID, PERCENT, DIVISION, PRINT, READ, FOLLOWS, SPACE;

nonterminal Program, NamespaceList, DeclList, MethodDeclList;
nonterminal Namespace, DeclType, ConstDecl, VarDecl, MethodDecl;
nonterminal Type, ConstType, ConstTypeList ;
nonterminal BracketForArray, ListVarDecl, StaticInitializer, StatementList;
nonterminal Statement, TypeList, FormParsOpt, VarDeclOpt, FormPars, ListFormPars;
nonterminal IdentOpt, DesignatorStatement, ElseOpt, ExprOpt, Designator;
nonterminal Expr, NumConstOpt, DesignatorStatementOpt, CondFactOpt, CondFact;
nonterminal ListExpressions, ListDesignator, Assignop, ActParsOpt, ListExpr, DesignatorOpt;
nonterminal Condition, CondTerm, CondTermList, OptRelop, CondFactList;
nonterminal Term, AdditionList, MinusOpt, Factor, MultiplicationList;
nonterminal OptParen, ListParams, ListIdent, Label, Relop, Addop, Mulop, ExprFactor, ActPars, Dec, Inc;
nonterminal AssignOperator, MtchStatement, UnmtchStatement;


Mulop				::= (PercentClass) PERCENT
					|
					(DivisionClass) DIVISION
					|
					(AsteriskClass) ASTERISK
					;

Addop				::= (MinusOpClass) MINUS
					|
					(AddOpClass) PLUS
					;

Relop				::= (LetClass) LET
					|
					(LtClass) LT
					|
					(GetClass) GET
					|
					(GtClass) GT
					|
					(DiffClass) DIFF
					|
					(EqualequalClass) EQUALEQUAL
					;

Assignop			::= (AssignopClass) EQUAL
					;

Label				::= (LabelIdentClass) IDENT
					;

ListIdent			::= (NoListIdentClass) /* epsilon */
					|
					(ExprListIdentClass) LBOXBRAC Expr RBOXBRAC
					|
					(IdentListIdentClass) DOT IDENT
					|
					(ListIdentClass) ListIdent 
					;

Designator			::= (DesignatorClass) IdentOpt IDENT ListIdent
					;

ListParams			::= (ListParamsActParsOptClass) LPAREN ActParsOpt RPAREN
					|
					(ListParamsExprExprClass) LBOXBRAC Expr RBOXBRAC
					;

OptParen 			::= (NoOptParenClass) /* epsilon */
					|
					(OptParenClass) LPAREN ActParsOpt RPAREN
					;


Factor				::= (ExprFactorClass) LPAREN Expr RPAREN
					|
					(NewTypeClass) NEW Type ListParams
					|
					(BoolConstClass) BOOLCONST
					|
					(LetterClass) LETTER
					|
					(NumberClass) NUMBER
					|
					(DesignatorClassBranch) Designator OptParen
					;

MultiplicationList	::= (NoMultiplicationListClass) /* epsilon */
					|
					(MultiplicationListClass) Mulop Factor MultiplicationList
					;



Term 				::= (TermClass) Factor MultiplicationList;

AdditionList		::= (NoAdditionListClass) /* epsilon */
					|
					(AdditionListClass) Addop Term AdditionList;
					
MinusOpt			::= (NoMinusOptClass) /* epsilon */
					|
					(MinusOptClass) MINUS;
Expr				::= (ExprClass) MinusOpt Term AdditionList;

OptRelop			::= (NoOptRelopClass) /* epsilon */
					|
					(OptRelopClass) Relop Expr;
CondFact			::= (NoCondFactClass) /* epsilon */	
					|
					(CondFactClass) Expr OptRelop;
CondFactList		::= (NoCondFactListClass) /* epsilon */
					|
					(CondFactListClass) AND CondFact CondFactList;
CondTerm			::= (NoCondTermClass) /* epsilon */
					|
					(CondTermClass) CondFact CondFactList;
CondTermList		::= (NoCondTermListClass) /* epsilon */
					|
					(CondTermListClass) OR CondTerm CondTermList
					;
Condition			::= (CondtionClass) CondTerm CondTermList
					;

DesignatorOpt		::= (NoDesignatorOptClass) /* epsilon */
					|
					(DesignaorOptClass) Designator
					;
ListDesignator		::= (NoListDesignatorClass) /* epsilon */
					|
					(ListDesignatorClass) ListDesignator DesignatorOpt COMMA
					;

ListExpr			::= (NoListExprClass) /* epsilon */
					|
					(ListExprClass) ListExpr COMMA Expr
					;
ActParsOpt			::= (NoActParsOptClass) /* epsilon */
					|
					(ActParsOptClass) ActPars
					;
ActPars 			::= (ActParsClass) Expr ListExpr
					;

ListExpressions		::= (NoListExpressions) /* epsilon */
					|
					(DecClass) Dec
					|
					(IncClass) Inc
					|
					(ParenOperatorClass) LPAREN ActParsOpt RPAREN
					|
					(AssignOperatorClass) AssignOperator Expr
					;

DesignatorStatement	::= (DesignatorStatementWithSomeOperationsClass) Designator ListExpressions 
					|
					(DesignatorStatementWithArrayClass) LBOXBRAC ListDesignator ASTERISK Designator RBOXBRAC EQUAL Designator
					;
					
CondFactOpt			::= (NoCondFactOptClass) /* epsilon */	
					|
					(CondFactOptClass) CondFact
					;
DesignatorStatementOpt ::= (DesignatorStatementTerminalClass) DesignatorStatement
						|
						(DesignatorStatementListClass) DesignatorStatementOpt COMMA DesignatorStatement
						;
NumConstOpt			::= (NoNumConstClass) /* epsilon */
					|
					(NumConstOptClass) COMMA NUMBER ;
ExprOpt				::= (NoExprClass) /* epsilon */
					|
					(ExprOptClass) Expr;



ElseOpt ::= (NoElseOptClass) /* epsilon */
          | (ElseOptClass) ELSE Statement;

Statement ::= (MatchedStmt) MtchStatement
		   |
		   (UnmatchedStmt) UnmtchStatement
		   ; 


UnmtchStatement ::= (UnmatchedIf) IF LPAREN Condition RPAREN Statement
		 	|
		 	(UnmatchedIfElse) IF LPAREN Condition RPAREN MtchStatement ELSE UnmtchStatement
		 	;

MtchStatement ::= (StatementListClassBranch) LBRACE StatementList RBRACE
           | (ForClass) FOR LPAREN DesignatorStatementOpt SEMI CondFactOpt SEMI DesignatorStatementOpt RPAREN Statement
           | (PrintClass) PRINT LPAREN Expr NumConstOpt RPAREN SEMI
           | (ReadClass) READ LPAREN Designator RPAREN SEMI
           | (ReturnClass) RETURN ExprOpt SEMI
           | (ContinueClass) CONTINUE SEMI
           | (BreakClass) BREAK SEMI
           | (IfClass) IF LPAREN Condition RPAREN Statement ElseOpt
           | (StatementClass) DesignatorStatement SEMI
           ;

IdentOpt ::= (NoIdentOptClass) /* epsilon */
           | (IdentOptClass) IDENT COL COL
           ;

Type ::= (TypeClass) IdentOpt IDENT
		;

ListFormPars ::= (NoListFormParsClass) /* epsilon */
              | (ListFormParsClass) ListFormPars COMMA Type IDENT BracketForArray
              ;

FormPars ::= (NoFormParsClass) /* epsilon */
           | (FormParsClass) Type IDENT BracketForArray ListFormPars
           ;

FormParsOpt ::= (NoFormParsOptClass) /* epsilon */
             | (FormParsOptClass) FormPars
             ;

VarDeclOpt ::= (NoVarDeclOptClass) /* epsilon */
            | (VarDeclOptClass) VarDecl
            ;

VarDecl ::= (NoVarDeclClass) /* epsilon */
          | (VarDeclClass) Type IDENT BracketForArray ListVarDecl SEMI
          ;

BracketForArray ::= (NoBracketForArrayClass) /* epsilon */
                | (BracketsForArrayClass) LBOXBRAC RBOXBRAC
                ;

ListVarDecl ::= (NoListVarDeclClass) /* epsilon */
             | (ListVarDeclClass) COMMA IDENT BracketForArray ListVarDecl
             ;

StaticInitializer ::= (StaticInitializerClass) STATIC LBRACE StatementList RBRACE
			;

StatementList ::= (NoStatementListClass) /* epsilon */
              | (StatementListClass) StatementList Statement
              ;

MethodDecl ::= (MethodDeclClass) TypeList IDENT LPAREN FormParsOpt RPAREN VarDeclOpt LBRACE StatementList RBRACE
			;

TypeList ::= (VoidTypeClass) VOID
          | (TypeMethodClass) Type
          ;

MethodDeclList ::= (NoMethodDeclListClass) /*epsilon*/
                 | (MethodDeclListClass) MethodDeclList MethodDecl
                 ;

Namespace ::= (NamespaceClass) NAMESPACE IDENT LBRACE DeclList LBRACE MethodDeclList RBRACE RBRACE
			;

ConstType ::= (BoolConstTypeClass) BOOLCONST
           | (CharConstTypeClass) LETTER
           | (NumConstTypeClass) NUMBER
           ;

ConstTypeList ::= (NoConstTypeListClass) /* epsilon */
               | (ConstTypeListClass) ConstTypeList COMMA IDENT EQUAL ConstType
               ;

ConstDecl ::= (ConstDeclClass) CONST Type IDENT EQUAL ConstType ConstTypeList
			;

NamespaceList ::=(NoNamespaceClass) /* epsilon */
               | (NamespaceListClass) NamespaceList Namespace
               ;

Program ::= (ProgramClass) PROG IDENT NamespaceList DeclList LBRACE MethodDeclList RBRACE
			;


