package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, LBRACE, RBRACE, NAMESPACE, CONST, EQUAL, COMMA, SEMI, STATIC;
terminal Integer NUMBER ;
terminal String IDENT ;
terminal String BOOLCONST ;
terminal String LETTER ;
terminal LBOXBRAC, RBOXBRAC, LPAREN, RPAREN, COL, IF, BREAK, ELSE, CONTINUE;
terminal RETURN, FOR, ASTERISK, INC, DEC, OR, AND, NEW, DOT, EQUALEQUAL, DIFF;
terminal GT, GET, LT, LET, PLUS, MINUS, VOID, PERCENT, DIVISION, PRINT, READ, FOLLOWS, SPACE, IDENTCOLCOL;

nonterminal Program, NamespaceList, DeclList, MethodDeclList;
nonterminal Namespace, DeclType, ConstDecl, VarDecl, MethodDecl;
nonterminal Type, ConstType, ConstTypeList ;
nonterminal BracketForArray, ListVarDecl, StaticInitializer, StatementList;
nonterminal Statement, TypeList, FormParsOpt, VarDeclOpt, FormPars, ListFormPars;
nonterminal IdentOpt, DesignatorStatement, ElseOpt, ExprOpt, Designator;
nonterminal Expr, NumConstOpt, DesignatorStatementOpt, CondFactOpt, CondFact;
nonterminal ListExpressions, ListDesignator, Assignop, ActParsOpt, ListExpr, DesignatorOpt;
nonterminal Condition, CondTerm, CondTermList, OptRelop, CondFactList;
nonterminal Term, AdditionList, MinusOpt, Factor, MultiplicationList;
nonterminal OptParen, ListParams, ListIdent, Label, Relop, Addop, Mulop, ExprFactor, ActPars;
nonterminal AssignOperator, MtchStatement, UnmtchStatement;


Program ::= (ProgramClass) PROG IDENT NamespaceList DeclList LBRACE MethodDeclList RBRACE
			;

NamespaceList ::=(NamespaceListClass) NamespaceList Namespace
				|
				(NoNamespaceClass) /* epsilon */
                ;

DeclList ::= (DeclListClass) DeclList DeclType
			|
			(NoDeclClass) /* epsilon */
			;

DeclType ::= (ConstDeclTypeClass) ConstDecl
			|
			(VarDeclTypeClass) VarDecl
			;

MethodDeclList ::=(MethodDeclListClass) MethodDeclList MethodDecl
				 | (NoMethodDeclListClass) /*epsilon*/
                 ;

Namespace ::= (NamespaceClass) NAMESPACE IDENT LBRACE DeclList LBRACE MethodDeclList RBRACE RBRACE
			;

ConstDecl ::= (ConstDeclClass) CONST Type IDENT EQUAL ConstType ConstTypeList
			;

ConstTypeList ::=(ConstTypeListClass) ConstTypeList COMMA IDENT EQUAL ConstType
				| (NoConstTypeListClass) /* epsilon */
                ;

ConstType ::= (BoolConstTypeClass) BOOLCONST
           | (CharConstTypeClass) LETTER
           | (NumConstTypeClass) NUMBER
           ;

TypeList ::= (VoidTypeClass) VOID
          | (TypeMethodClass) Type
          ;

MethodDecl ::= (MethodDeclClass) TypeList IDENT LPAREN FormParsOpt RPAREN VarDeclOpt LBRACE StatementList RBRACE
			;

StatementList ::= (StatementListClass) StatementList Statement
				| (NoStatementListClass) /* epsilon */
                ;

StaticInitializer ::= (StaticInitializerClass) STATIC LBRACE StatementList RBRACE
			;

ListVarDecl ::= (ListVarDeclClass) ListVarDecl COMMA IDENT BracketForArray
				|
				(NoListVarDeclClass) /* epsilon */
                ;

BracketForArray ::= (BracketsForArrayClass) LBOXBRAC RBOXBRAC
				|
				(NoBracketForArrayClass) /* epsilon */
                ;

VarDecl ::= (VarDeclClass) Type IDENT BracketForArray ListVarDecl SEMI
			|
			(NoVarDeclClass) /* epsilon */
          	;

VarDeclOpt ::= (VarDeclOptClass) VarDecl
			|
			(NoVarDeclOptClass) /* epsilon */
            ;

FormParsOpt ::= (FormParsOptClass) FormPars
				| 
				(NoFormParsOptClass) /* epsilon */
                ;

FormPars ::= (FormParsClass) Type IDENT BracketForArray ListFormPars
			 |
			 (NoFormParsClass) /* epsilon */
            ;

ListFormPars ::= (ListFormParsClass) ListFormPars COMMA Type IDENT BracketForArray
				|
				(NoListFormParsClass) /* epsilon */
                ;

Type ::= (TypeClass) IdentOpt IDENT
		;

IdentOpt ::= (IdentOptClass) IDENTCOLCOL
			 |
			 (NoIdentOptClass) /* epsilon */
             ;


Statement ::= (MatchedStmt) MtchStatement
		   |
		   (UnmatchedStmt) UnmtchStatement
		   ; 

MtchStatement ::= (StatementListClassBranch) LBRACE StatementList RBRACE
           | (ForClass) FOR LPAREN DesignatorStatementOpt SEMI CondFactOpt SEMI DesignatorStatementOpt RPAREN Statement
           | (PrintClass) PRINT LPAREN Expr NumConstOpt RPAREN SEMI
           | (ReadClass) READ LPAREN Designator RPAREN SEMI
           | (ReturnClass) RETURN ExprOpt SEMI
           | (ContinueClass) CONTINUE SEMI
           | (BreakClass) BREAK SEMI
           | (IfClass) IF LPAREN Condition RPAREN Statement ElseOpt
           | (StatementClass) DesignatorStatement SEMI
           ;

UnmtchStatement ::= (UnmatchedIf) IF LPAREN Condition RPAREN Statement
		 	|
		 	(UnmatchedIfElse) IF LPAREN Condition RPAREN MtchStatement ELSE UnmtchStatement
		 	;



ElseOpt ::= (ElseOptClass) ELSE Statement
			|
			(NoElseOptClass) /* epsilon */
			;

ExprOpt				::= (ExprOptClass) Expr
					|
					(NoExprClass) /* epsilon */
					;

NumConstOpt			::=
					(NumConstOptClass) COMMA NUMBER
					|
					(NoNumConstClass) /* epsilon */
					;

DesignatorStatementOpt ::= (DesignatorStatementTerminalClass) DesignatorStatement
						|
						(DesignatorStatementListClass) DesignatorStatementOpt COMMA DesignatorStatement
						;

CondFactOpt			::= (CondFactOptClass) CondFact
					|
					(NoCondFactOptClass) /* epsilon */
					;

DesignatorStatement	::= (DesignatorStatementWithSomeOperationsClass) Designator ListExpressions 
					|
					(DesignatorStatementWithArrayClass) LBOXBRAC ListDesignator ASTERISK Designator RBOXBRAC EQUAL Designator
					;

ListExpressions		::= (AssignOperatorClass) AssignOperator Expr
					|
					(ParenOperatorClass) LPAREN ActParsOpt RPAREN
					|
					(DecClass) INC
					|
					(IncClass) DEC
					;

ActPars 			::= (ActParsClass) Expr ListExpr
					;

ActParsOpt			::= (ActParsOptClass) ActPars
					|
					(NoActParsOptClass) /* epsilon */
					;

ListExpr			::= (ListExprClass) ListExpr COMMA Expr
					|
					(NoListExprClass) /* epsilon */
					;

ListDesignator		::= (ListDesignatorClass) ListDesignator DesignatorOpt COMMA
					|
					(NoListDesignatorClass) /* epsilon */
					;

DesignatorOpt		::= (DesignaorOptClass) Designator
					|
					(NoDesignatorOptClass) /* epsilon */
					;

Condition			::= (CondtionClass) CondTerm CondTermList
					;

CondTermList		::= (CondTermListClass) OR CondTerm CondTermList
					|
					(NoCondTermListClass) /* epsilon */
					;

CondTerm			::= (CondTermClass) CondFact CondFactList
					|
					(NoCondTermClass) /* epsilon */
					;

CondFactList		::= (CondFactListClass) AND CondFact CondFactList
					|
					(NoCondFactListClass) /* epsilon */
					;

CondFact			::= (CondFactClass) Expr OptRelop
					|
					(NoCondFactClass) /* epsilon */
					;

OptRelop			::= (OptRelopClass) Relop Expr
					|
					(NoOptRelopClass) /* epsilon */
					;

Expr				::= (ExprClass) MinusOpt Term AdditionList
					;

MinusOpt			::= (MinusOptClass) MINUS
					|
					(NoMinusOptClass) /* epsilon */
					;

AdditionList		::= (AdditionListClass) Addop Term AdditionList
					|
					(NoAdditionListClass) /* epsilon */
					;
					
					
Term 				::= (TermClass) Factor MultiplicationList
					;

MultiplicationList	::= (MultiplicationListClass) Mulop Factor MultiplicationList
					|
					(NoMultiplicationListClass) /* epsilon */
					;

Factor				::= (ExprFactorClass) LPAREN Expr RPAREN
					|
					(NewTypeClass) NEW Type ListParams
					|
					(BoolConstClass) BOOLCONST
					|
					(LetterClass) LETTER
					|
					(NumberClass) NUMBER
					|
					(DesignatorClassBranch) Designator OptParen
					;

OptParen 			::= (OptParenClass) LPAREN ActParsOpt RPAREN
					|
					(NoOptParenClass) /* epsilon */
					;

ListParams			::= (ListParamsActParsOptClass) LPAREN ActParsOpt RPAREN
					|
					(ListParamsExprExprClass) LBOXBRAC Expr RBOXBRAC
					;

Designator			::= (DesignatorClass) IdentOpt IDENT ListIdent
					;

ListIdent			::= (ListIdentClass) ListIdent
					|
					(IdentListIdentClass) DOT IDENT
					|
					(ExprListIdentClass) LBOXBRAC Expr RBOXBRAC
					|
					(NoListIdentClass) /* epsilon */
					;

Label				::= (LabelIdentClass) IDENT
					;

Assignop			::= (AssignopClass) EQUAL
					;

Relop				::= (LetClass) LET
					|
					(LtClass) LT
					|
					(GetClass) GET
					|
					(GtClass) GT
					|
					(DiffClass) DIFF
					|
					(EqualequalClass) EQUALEQUAL
					;

Addop				::= (MinusOpClass) MINUS
					|
					(AddOpClass) PLUS
					;

Mulop				::= (PercentClass) PERCENT
					|
					(DivisionClass) DIVISION
					|
					(AsteriskClass) ASTERISK
					;
 
               