package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
    
:}

init with {:
	errorDetected = false;
:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG, LBRACE, RBRACE, NAMESPACE, CONST, EQUAL, COMMA, SEMI, STATIC;
terminal Integer NUMBER ;
terminal String TRUE ;
terminal String FALSE ;
terminal String IDENT ;
terminal String BOOLCONST ;
terminal char LETTER ;
terminal LBOXBRAC, RBOXBRAC, LPAREN, RPAREN, COL, IF, BREAK, ELSE, CONTINUE;
terminal RETURN, FOR, ASTERISK, INC, DEC, OR, AND, NEW, DOT, EQUALEQUAL, DIFF;
terminal GT, GET, LT, LET, PLUS, MINUS, VOID, PERCENT, DIVISION, PRINT, READ, FOLLOWS, SPACE, IDENTCOLCOL;

nonterminal NamespaceList NamespaceList;
nonterminal DeclList DeclList;
nonterminal MethodDeclList MethodDeclList;
nonterminal Namespace Namespace;
nonterminal DeclType DeclType;
nonterminal ConstDecl ConstDecl;
nonterminal VarDecl VarDecl;
nonterminal ConstTypeList ConstTypeList ;
nonterminal BracketForArray BracketForArray;
nonterminal StaticInitializer StaticInitializer;
nonterminal StatementList StatementList;
nonterminal Statement Statement;
nonterminal TypeList TypeList;
nonterminal FormParsOpt FormParsOpt;
nonterminal VarDeclOpt VarDeclOpt;
nonterminal FormPars FormPars;
nonterminal ListFormPars ListFormPars;
nonterminal IdentOpt IdentOpt;
nonterminal DesignatorStatement DesignatorStatement;
nonterminal ElseOpt ElseOpt;
nonterminal ExprOpt ExprOpt;
nonterminal NumConstOpt NumConstOpt;
nonterminal DesignatorStatementOpt DesignatorStatementOpt;
nonterminal CondFactOpt CondFactOpt;
nonterminal CondFact CondFact;
nonterminal ListExpressions ListExpressions;
nonterminal ListDesignator ListDesignator;
nonterminal Assignop Assignop;
nonterminal ActParsOpt ActParsOpt;
nonterminal ListExpr ListExpr;
nonterminal DesignatorOpt DesignatorOpt;
nonterminal Condition Condition;
nonterminal CondTerm CondTerm;
nonterminal CondTermList CondTermList;
nonterminal OptRelop OptRelop;
nonterminal CondFactList CondFactList;
nonterminal AdditionList AdditionList;
nonterminal MinusOpt MinusOpt;
nonterminal MultiplicationList MultiplicationList;
nonterminal OptParen OptParen;
nonterminal ListParams ListParams;
nonterminal ListIdent ListIdent;
nonterminal Label Label;
nonterminal Relop Relop;
nonterminal Addop Addop;
nonterminal Mulop Mulop;
nonterminal ExprFactor ExprFactor;
nonterminal ActPars ActPars;
nonterminal MtchStatement MtchStatement;
nonterminal UnmtchStatement UnmtchStatement;
nonterminal MethodDeclVarList MethodDeclVarList;
nonterminal SufixForIdent SufixForIdent;
nonterminal ReturnNoExprClass ReturnNoExprClass;
nonterminal ConstInit ConstInit;
nonterminal EndOfNamespace EndOfNamespace;
nonterminal NamespaceName NamespaceName;


nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName, Program, MethodDecl, MethodTypeName, Designator, KindOfVar, KindOfPar, NameOfArray, NameOfArrayWithPrefix, DesignatorWithPrefixArray;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type, Term, Factor, Expr, ListVarDecl, ConstType, Boolconst;



precedence left ELSE;


Program ::= (ProgramClass) PROG ProgName:p NamespaceList:N1 DeclList:D2 LBRACE MethodDeclList:M3 RBRACE {: RESULT=new ProgramClass(p, N1, D2, M3); RESULT.setLine(pleft); :}
			;

ProgName ::= (ProgNameClass) IDENT:progName {: RESULT=new ProgNameClass(progName); RESULT.setLine(progNameleft); :};

NamespaceList ::=(NamespaceListClass) NamespaceList:N1 Namespace:N2 {: RESULT=new NamespaceListClass(N1, N2); RESULT.setLine(N1left); :}
				|
				(NoNamespaceClass) {: RESULT=new NoNamespaceClass(); :} /* epsilon */
                ;

DeclList ::= (DeclListClass) DeclList:D1 DeclType:D2 {: RESULT=new DeclListClass(D1, D2); RESULT.setLine(D1left); :}
			|
			(NoDeclClass) {: RESULT=new NoDeclClass(); :} /* epsilon */
			;

DeclType ::= (ConstDeclTypeClass) ConstDecl:C1 {: RESULT=new ConstDeclTypeClass(C1); RESULT.setLine(C1left); :}
			|
			(VarDeclTypeClass) VarDecl:V1 {: RESULT=new VarDeclTypeClass(V1); RESULT.setLine(V1left); :}
			;

MethodDeclList ::=(MethodDeclListClass) MethodDeclList:M1 MethodDecl:M2 {: RESULT=new MethodDeclListClass(M1, M2); RESULT.setLine(M1left); :}
				 | (NoMethodDeclListClass) {: RESULT=new NoMethodDeclListClass(); :} /*epsilon*/
                 ;

Namespace ::= (NamespaceClass) NAMESPACE NamespaceName:N1 LBRACE DeclList:D2 LBRACE MethodDeclList:M3 RBRACE EndOfNamespace:E4 {: RESULT=new NamespaceClass(N1, D2, M3, E4); RESULT.setLine(N1left); :}
			;
			
NamespaceName ::= (NamespaceNameClass) IDENT:Name {: RESULT=new NamespaceNameClass(Name); RESULT.setLine(Nameleft); :}
				;			

EndOfNamespace ::= (EndOfNamespace) RBRACE {: RESULT=new EndOfNamespace(); :}
				;

ConstDecl ::= (ConstDeclClass) CONST Type:T1 ConstInit:C2 ConstTypeList:C3 SEMI {: RESULT=new ConstDeclClass(T1, C2, C3); RESULT.setLine(T1left); :}
			;
			
ConstInit ::= (ConstInitClass) IDENT:Name EQUAL ConstType:value {: RESULT=new ConstInitClass(Name, value); RESULT.setLine(Nameleft); :}
			;

ConstTypeList ::=(ConstTypeListClass) ConstTypeList:C1 COMMA ConstInit:C2 {: RESULT=new ConstTypeListClass(C1, C2); RESULT.setLine(C1left); :}
				| (NoConstTypeListClass) {: RESULT=new NoConstTypeListClass(); :} /* epsilon */
                ;

ConstType ::= (BoolConstTypeClass) Boolconst:B1 {: RESULT=new BoolConstTypeClass(B1); RESULT.setLine(B1left); :}
           | (CharConstTypeClass) LETTER:value {: RESULT=new CharConstTypeClass(value); RESULT.setLine(valueleft); :}
           | (NumConstTypeClass) NUMBER:value {: RESULT=new NumConstTypeClass(value); RESULT.setLine(valueleft); :}
           ;
           
Boolconst ::= (TrueClass) TRUE:valTrue {: RESULT=new TrueClass(valTrue); RESULT.setLine(valTrueleft); :}
			|
			(FalseClass) FALSE:valFalse {: RESULT=new FalseClass(valFalse); RESULT.setLine(valFalseleft); :}
			;
           
Type ::= (TypeClass) IDENT:typeName {: RESULT=new TypeClass(typeName); RESULT.setLine(typeNameleft); :}
		|
		(TypeWithPrefixClass) IDENT:I1 COL COL IDENT:typeName {: RESULT=new TypeWithPrefixClass(I1, typeName); RESULT.setLine(I1left); :} /* ovo je ja mislim samo ako imam klasu unutar namespacea */
		;

IdentOpt ::= (IdentOptClass) IDENT:I1 COL COL {: RESULT=new IdentOptClass(I1); RESULT.setLine(I1left); :}
			 |
			 (NoIdentOptClass) {: RESULT=new NoIdentOptClass(); :} /* epsilon */
             ;

TypeList ::= (VoidTypeClass) VOID {: RESULT=new VoidTypeClass(); :}
          | (TypeMethodClass) Type:T1 {: RESULT=new TypeMethodClass(T1); RESULT.setLine(T1left); :}
          ;
          

VarDecl ::= (VarDeclClass) Type:varType KindOfVar:K1 ListVarDecl:L2 SEMI {: RESULT=new VarDeclClass(varType, K1, L2); RESULT.setLine(varTypeleft); :}
			|
			(ClassSemiError) error SEMI:l
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new ClassSemiError(); :}
          	;
          	
          	
KindOfVar ::= (VarNoArrayClass) IDENT:name {: RESULT=new VarNoArrayClass(name); RESULT.setLine(nameleft); :}
			|
			(VarArrayClass) IDENT:name LBOXBRAC RBOXBRAC {: RESULT=new VarArrayClass(name); RESULT.setLine(nameleft); :}
			;

VarDeclOpt ::= (VarDeclOptClass) VarDecl:V1 {: RESULT=new VarDeclOptClass(V1); RESULT.setLine(V1left); :}
			|
			(NoVarDeclOptClass) {: RESULT=new NoVarDeclOptClass(); :} /* epsilon */
            ;
            
ListVarDecl ::= (ListVarDeclClass) COMMA KindOfVar:K1 ListVarDecl:L2 {: RESULT=new ListVarDeclClass(K1, L2); RESULT.setLine(K1left); :} 
				|
				(ClassCommaError) COMMA:l error
				{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new ClassCommaError(); :}
				
				|
				(NoListVarDeclClass) {: RESULT=new NoListVarDeclClass(); :} /* epsilon */
                ;

BracketForArray ::= (BracketsForArrayClass) LBOXBRAC RBOXBRAC {: RESULT=new BracketsForArrayClass(); :}
				|
				(NoBracketForArrayClass) {: RESULT=new NoBracketForArrayClass(); :} /* epsilon */
                ;

MethodDecl ::= (MethodDeclClass) MethodTypeName:M1 LPAREN FormParsOpt:F2 RPAREN MethodDeclVarList:M3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDeclClass(M1, F2, M3, S4); RESULT.setLine(M1left); :}
			;
			
MethodTypeName ::= (ReturnTypeClass) Type:t IDENT:methName {: RESULT=new ReturnTypeClass(t, methName); RESULT.setLine(tleft); :}
				|
				(VoidRetTypeClass) VOID IDENT:methName {: RESULT=new VoidRetTypeClass(methName); RESULT.setLine(methNameleft); :}
				;

FormParsOpt ::= (FormParsOptClass) FormPars:F1 {: RESULT=new FormParsOptClass(F1); RESULT.setLine(F1left); :}
				| 
				(NoFormParsOptClass) {: RESULT=new NoFormParsOptClass(); :} /* epsilon */
                ;

FormPars ::= (FormParsClass) Type:T1 KindOfPar:K2 ListFormPars:L3 {: RESULT=new FormParsClass(T1, K2, L3); RESULT.setLine(T1left); :}
            	;

ListFormPars ::= (ListFormParsClass) ListFormPars:L1 COMMA Type:T2 KindOfPar:K3 {: RESULT=new ListFormParsClass(L1, T2, K3); RESULT.setLine(L1left); :}
				|
				(NoListFormParsClass) {: RESULT=new NoListFormParsClass(); :} /* epsilon */
                ;

KindOfPar ::= (ParNoArrayClass) IDENT:name {: RESULT=new ParNoArrayClass(name); RESULT.setLine(nameleft); :}
			|
			(ParArrayClass) IDENT:name LBOXBRAC RBOXBRAC {: RESULT=new ParArrayClass(name); RESULT.setLine(nameleft); :}
			;
                
MethodDeclVarList ::= (MethodDeclVarListClass) MethodDeclVarList:M1 VarDecl:V2 {: RESULT=new MethodDeclVarListClass(M1, V2); RESULT.setLine(M1left); :} 
					|
					(NoMethodDeclVarListClass) {: RESULT=new NoMethodDeclVarListClass(); :} /* epsilon */
					;

StatementList ::= (StatementListClass) StatementList:S1 Statement:S2 {: RESULT=new StatementListClass(S1, S2); RESULT.setLine(S1left); :}
				| (NoStatementListClass) {: RESULT=new NoStatementListClass(); :} /* epsilon */
                ;

StaticInitializer ::= (StaticInitializerClass) STATIC LBRACE StatementList:S1 RBRACE {: RESULT=new StaticInitializerClass(S1); RESULT.setLine(S1left); :}
			;








Statement ::= (StatementClass) DesignatorStatement:D1 SEMI {: RESULT=new StatementClass(D1); RESULT.setLine(D1left); :}
			|
			(ClassSemiError2) error SEMI:l
			{: parser.report_error("Izvrsen oporavak do ; u liniji " + lleft, null);  :} {: RESULT=new ClassSemiError2(); :}
           |
           (IfClass) IF LPAREN Condition:C1 RPAREN Statement:S2 ElseOpt:E3 {: RESULT=new IfClass(C1, S2, E3); RESULT.setLine(C1left); :}
           |
           (BreakClass) BREAK SEMI {: RESULT=new BreakClass(); :}
           |
           (ContinueClass) CONTINUE SEMI {: RESULT=new ContinueClass(); :}
           |
           (ReturnClass) RETURN Expr:t SEMI {: RESULT=new ReturnClass(t); RESULT.setLine(tleft); :}
           |
           (ReturnNoExpressionClass) RETURN SEMI {: RESULT=new ReturnNoExpressionClass(); :}
           |
           (ReadClass) READ LPAREN Designator:D1 RPAREN SEMI {: RESULT=new ReadClass(D1); RESULT.setLine(D1left); :}
           |
           (PrintClass) PRINT LPAREN Expr:E1 NumConstOpt:N2 RPAREN SEMI {: RESULT=new PrintClass(E1, N2); RESULT.setLine(E1left); :}
           |
           (ForClass) FOR LPAREN DesignatorStatementOpt:D1 SEMI CondFactOpt:C2 SEMI DesignatorStatementOpt:D3 RPAREN Statement:S4 {: RESULT=new ForClass(D1, C2, D3, S4); RESULT.setLine(D1left); :}
           |
           (StatementListClassBranch) LBRACE StatementList:S1 RBRACE {: RESULT=new StatementListClassBranch(S1); RESULT.setLine(S1left); :}
           ;




DesignatorStatement	::= (AssignOperatorClass) Designator:dest Assignop:A1 Expr:e {: RESULT=new AssignOperatorClass(dest, A1, e); RESULT.setLine(destleft); :}
					|
					(ProcCallClass) Designator:dest LPAREN ActParsOpt:A1 RPAREN {: RESULT=new ProcCallClass(dest, A1); RESULT.setLine(destleft); :}
					|
					(IncClass) Designator:dest INC {: RESULT=new IncClass(dest); RESULT.setLine(destleft); :}
					|
					(DecClass) Designator:dest DEC {: RESULT=new DecClass(dest); RESULT.setLine(destleft); :} 
					|
					(DesignatorStatementWithArrayClass) LBOXBRAC ListDesignator:L1 ASTERISK Designator:D2 RBOXBRAC EQUAL Designator:D3 {: RESULT=new DesignatorStatementWithArrayClass(L1, D2, D3); RESULT.setLine(L1left); :}
					;

Designator			::= (DesignatorClass) IDENT:desigName {: RESULT=new DesignatorClass(desigName); RESULT.setLine(desigNameleft); :}
					|
					(DesignatorArrayClass) NameOfArray:N1 LBOXBRAC Expr:E2 RBOXBRAC {: RESULT=new DesignatorArrayClass(N1, E2); RESULT.setLine(N1left); :}
					|
					(DesignatorWithPrefixClass) IDENT:prefix COL COL IDENT:desigName {: RESULT=new DesignatorWithPrefixClass(prefix, desigName); RESULT.setLine(prefixleft); :}
					|
					(DesignatorWithPrefixArrayClass) NameOfArrayWithPrefix:N1 LBOXBRAC Expr:E2 RBOXBRAC {: RESULT=new DesignatorWithPrefixArrayClass(N1, E2); RESULT.setLine(N1left); :}
					;
					
NameOfArray			::= (NameOfArrayClass) IDENT:desigName {: RESULT=new NameOfArrayClass(desigName); RESULT.setLine(desigNameleft); :}
					;
					
NameOfArrayWithPrefix ::= (NameOfArrayWithPrefixClass) IDENT:prefix COL COL IDENT:desigName {: RESULT=new NameOfArrayWithPrefixClass(prefix, desigName); RESULT.setLine(prefixleft); :}
						;
					
ListIdent			::= (ListIdentClass) ListIdent:L1 SufixForIdent:S2 {: RESULT=new ListIdentClass(L1, S2); RESULT.setLine(L1left); :}
					|
					(NoListIdentClass) {: RESULT=new NoListIdentClass(); :} /* epsilon */
					;
					
SufixForIdent 		::= (IdentListIdentClass) DOT IDENT:I1 {: RESULT=new IdentListIdentClass(I1); RESULT.setLine(I1left); :}
					|
					(ExprListIdentClass) LBOXBRAC Expr:E1 RBOXBRAC {: RESULT=new ExprListIdentClass(E1); RESULT.setLine(E1left); :}
					;

ActPars 			::= (ActParsClass) Expr:E1 ListExpr:L2 {: RESULT=new ActParsClass(E1, L2); RESULT.setLine(E1left); :}
					;

ActParsOpt			::= (ActParsOptClass) ActPars:A1 {: RESULT=new ActParsOptClass(A1); RESULT.setLine(A1left); :}
					|
					(NoActParsOptClass) {: RESULT=new NoActParsOptClass(); :} /* epsilon */
					;	
					
Expr				::= (AddExprClass) Expr:te Addop:A1 Term:t {: RESULT=new AddExprClass(te, A1, t); RESULT.setLine(teleft); :}
					|
					(ExprClass) MinusOpt:M1 Term:te {: RESULT=new ExprClass(M1, te); RESULT.setLine(M1left); :}
					;					
MinusOpt			::= (MinusOptClass) MINUS {: RESULT=new MinusOptClass(); :}
					|
					(NoMinusOptClass) {: RESULT=new NoMinusOptClass(); :} /* epsilon */
					;

AdditionList		::= (AdditionListClass) Addop:A1 Term:T2 AdditionList:A3 {: RESULT=new AdditionListClass(A1, T2, A3); RESULT.setLine(A1left); :}
					|
					(NoAdditionListClass) {: RESULT=new NoAdditionListClass(); :} /* epsilon */
					;
					
					
Term 				::= (TermClass) Factor:F1 MultiplicationList:M2 {: RESULT=new TermClass(F1, M2); RESULT.setLine(F1left); :}
					;

MultiplicationList	::= (MultiplicationListClass) Mulop:M1 MultiplicationList:M2 {: RESULT=new MultiplicationListClass(M1, M2); RESULT.setLine(M1left); :}
					|
					(NoMultiplicationListClass) {: RESULT=new NoMultiplicationListClass(); :} /* epsilon */
					;

Factor				::= (ExprFactorClass) LPAREN Expr:E1 RPAREN {: RESULT=new ExprFactorClass(E1); RESULT.setLine(E1left); :}
					|
					(NewTypeClass) NEW Type:nameOfType ListParams:L1 {: RESULT=new NewTypeClass(nameOfType, L1); RESULT.setLine(nameOfTypeleft); :}
					|
					(BoolConstClass) Boolconst:B1 {: RESULT=new BoolConstClass(B1); RESULT.setLine(B1left); :}
					|
					(LetterClass) LETTER:L1 {: RESULT=new LetterClass(L1); RESULT.setLine(L1left); :}
					|
					(NumberClass) NUMBER:N1 {: RESULT=new NumberClass(N1); RESULT.setLine(N1left); :}
					|
					(FunCallClass) Designator:func LPAREN ActParsOpt:A1 RPAREN {: RESULT=new FunCallClass(func, A1); RESULT.setLine(funcleft); :}
					|
					(VarClass) Designator:d {: RESULT=new VarClass(d); RESULT.setLine(dleft); :}
					;

OptParen 			::= (OptParenClass) LPAREN ActParsOpt:A1 RPAREN {: RESULT=new OptParenClass(A1); RESULT.setLine(A1left); :}
					|
					(NoOptParenClass) {: RESULT=new NoOptParenClass(); :} /* epsilon */
					;

ListParams			::= (ListParamsActParsOptClass) LPAREN ActParsOpt:A1 RPAREN {: RESULT=new ListParamsActParsOptClass(A1); RESULT.setLine(A1left); :}
					|
					(ListParamsExprExprClass) LBOXBRAC Expr:E1 RBOXBRAC {: RESULT=new ListParamsExprExprClass(E1); RESULT.setLine(E1left); :}
					;
				
					
NumConstOpt			::=
					(NumConstOptClass) COMMA NUMBER:width {: RESULT=new NumConstOptClass(width); RESULT.setLine(widthleft); :}
					|
					(NoNumConstClass) {: RESULT=new NoNumConstClass(); :} /* epsilon */
					;			
					



ElseOpt ::= (ElseOptClass) ELSE Statement:S1 {: RESULT=new ElseOptClass(S1); RESULT.setLine(S1left); :}
			|
			(NoElseOptClass) {: RESULT=new NoElseOptClass(); :} /* epsilon */
			;

ExprOpt				::= (ExprOptClass) Expr:E1 {: RESULT=new ExprOptClass(E1); RESULT.setLine(E1left); :}
					|
					(NoExprClass) {: RESULT=new NoExprClass(); :} /* epsilon */
					;



DesignatorStatementOpt ::= (DesignatorStatementTerminalClass) DesignatorStatement:D1 {: RESULT=new DesignatorStatementTerminalClass(D1); RESULT.setLine(D1left); :}
						|
						(DesignatorStatementListClass) DesignatorStatementOpt:D1 COMMA DesignatorStatement:D2 {: RESULT=new DesignatorStatementListClass(D1, D2); RESULT.setLine(D1left); :}
						|
						(NoDesignatorStatementOptClass) {: RESULT=new NoDesignatorStatementOptClass(); :} /* epsilon */
						;






CondFact			::= (CondFactClass) Expr:E1 OptRelop:O2 {: RESULT=new CondFactClass(E1, O2); RESULT.setLine(E1left); :}
					;


CondFactOpt			::= (CondFactOptClass) CondFact:C1 {: RESULT=new CondFactOptClass(C1); RESULT.setLine(C1left); :}
					|
					(NoCondFactOptClass) {: RESULT=new NoCondFactOptClass(); :} /* epsilon */
					;




ListExpr			::= (ListExprClass) ListExpr:L1 COMMA Expr:E2 {: RESULT=new ListExprClass(L1, E2); RESULT.setLine(L1left); :}
					|
					(NoListExprClass) {: RESULT=new NoListExprClass(); :} /* epsilon */
					;

ListDesignator		::= (ListDesignatorClass) ListDesignator:L1 DesignatorOpt:D2 COMMA {: RESULT=new ListDesignatorClass(L1, D2); RESULT.setLine(L1left); :}
					|
					(NoListDesignatorClass) {: RESULT=new NoListDesignatorClass(); :} /* epsilon */
					;

DesignatorOpt		::= (DesignaorOptClass) Designator:D1 {: RESULT=new DesignaorOptClass(D1); RESULT.setLine(D1left); :}
					|
					(NoDesignatorOptClass) {: RESULT=new NoDesignatorOptClass(); :} /* epsilon */
					;

Condition			::= (CondtionClass) CondTerm:C1 CondTermList:C2 {: RESULT=new CondtionClass(C1, C2); RESULT.setLine(C1left); :}
					;

CondTermList		::= (CondTermListClass) OR CondTerm:C1 CondTermList:C2 {: RESULT=new CondTermListClass(C1, C2); RESULT.setLine(C1left); :}
					|
					(NoCondTermListClass) {: RESULT=new NoCondTermListClass(); :} /* epsilon */
					;

CondTerm			::= (CondTermClass) CondFact:C1 CondFactList:C2 {: RESULT=new CondTermClass(C1, C2); RESULT.setLine(C1left); :}
					;

CondFactList		::= (CondFactListClass) AND CondFact:C1 CondFactList:C2 {: RESULT=new CondFactListClass(C1, C2); RESULT.setLine(C1left); :}
					|
					(NoCondFactListClass) {: RESULT=new NoCondFactListClass(); :} /* epsilon */
					;



OptRelop			::= (OptRelopClass) Relop:R1 Expr:E2 {: RESULT=new OptRelopClass(R1, E2); RESULT.setLine(R1left); :}
					|
					(NoOptRelopClass) {: RESULT=new NoOptRelopClass(); :} /* epsilon */
					;


















Label				::= (LabelIdentClass) IDENT:I1 {: RESULT=new LabelIdentClass(I1); RESULT.setLine(I1left); :}
					;

Assignop			::= (AssignopClass) EQUAL {: RESULT=new AssignopClass(); :}
					;

Relop				::= (LetClass) LET {: RESULT=new LetClass(); :}
					|
					(LtClass) LT {: RESULT=new LtClass(); :}
					|
					(GetClass) GET {: RESULT=new GetClass(); :}
					|
					(GtClass) GT {: RESULT=new GtClass(); :}
					|
					(DiffClass) DIFF {: RESULT=new DiffClass(); :}
					|
					(EqualequalClass) EQUALEQUAL {: RESULT=new EqualequalClass(); :}
					;

Addop				::= (MinusOpClass) MINUS {: RESULT=new MinusOpClass(); :}
					|
					(AddOpClass) PLUS {: RESULT=new AddOpClass(); :}
					;

Mulop				::= (PercentClass) PERCENT Factor:F1 {: RESULT=new PercentClass(F1); RESULT.setLine(F1left); :}
					|
					(DivisionClass) DIVISION Factor:F1 {: RESULT=new DivisionClass(F1); RESULT.setLine(F1left); :}
					|
					(AsteriskClass) ASTERISK Factor:F1 {: RESULT=new AsteriskClass(F1); RESULT.setLine(F1left); :}
					;
 
               